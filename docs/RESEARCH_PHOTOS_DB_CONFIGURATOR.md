# Исследование: фото в БД, готовность БД и использование данных в конфигураторе

Дата: 10.02.2025

---

## 1. Фото загружаем в БД — как это устроено и что делать

### 1.1 Текущая модель хранения фото

В приложении **две независимые системы** хранения фото:

| Система | Таблица | Назначение | Где используется |
|--------|---------|------------|-------------------|
| **ProductImage** | `product_images` | Изображения товара (1:N к Product) | Каталог товаров, конструктор, карточки товара, API `/api/catalog/products`, `/api/catalog/configurable-products` |
| **PropertyPhoto** | `property_photos` | Фото по свойству (модель/артикул/цвет) | **Конфигуратор дверей**: `/api/catalog/doors/complete-data`, `/api/catalog/doors/photos-batch` |

**ProductImage** (schema):

- Поля: `product_id`, `url`, `filename`, `original_name`, `mime_type`, `is_primary`, `sort_order`, `alt_text`, `width`, `height`, `file_size`.
- **В БД хранится только ссылка** (`url`). Бинарных данных в БД нет.
- Загрузка файлов: `app/api/upload/route.ts` → Yandex Object Storage (`lib/storage/yandex-storage.ts`). После загрузки в хранилище в БД пишется URL (например `https://bucket.storage.yandexcloud.net/...`).
- Добавление записи: `productRepository.addImage(productId, { url, filename, ... })`.

**PropertyPhoto** (schema):

- Поля: `categoryId`, `propertyName`, `propertyValue`, `photoPath`, `photoType` (cover, gallery_1, gallery_2, …).
- Используется **только для дверей**: фото привязаны к значению свойства («Артикул поставщика» или «Domeo_Название модели для Web»).
- В коде ожидается путь вида **`/uploads/...`** (локальный или относительный). Полные `https://` URL в текущем коде не обрабатываются.

### 1.2 Что значит «фото загружаем в БД»

Варианты:

1. **Только учёт в БД (метаданные + URL)**  
   В `ProductImage.url` или `PropertyPhoto.photoPath` сохраняем **ссылку из файла** (Yandex 360). Файл физически остаётся на 360. Минус: зависимость от доступности и срока жизни ссылок.

2. **Фото физически у нас**  
   Скачать по ссылке из Excel → загрузить в своё хранилище (Yandex Object Storage или `public/uploads`) → в БД записать **уже наш** URL/путь. Тогда «загружены в БД» = «учтены в БД и файлы лежат у нас».

Рекомендация по шагам:

- **Сначала:** сохранять в БД существующие URL из файла (вариант 1), чтобы импорт и конфигуратор заработали.
- **Отдельной задачей:** скрипт/опция «скачать по URL → загрузить в Yandex Storage (или `public/uploads`) → обновить `url`/`photoPath` в БД» (вариант 2).

### 1.3 Важно для дверей: PropertyPhoto и фронт

- Фото дверей в конфигураторе берутся из **PropertyPhoto**, а не из ProductImage.
- `complete-data` и `photos-batch` вызывают `getPropertyPhotos()` и возвращают пути в формате **`/uploads/...`**.
- В `StickyPreview.tsx` и `ModernPhotoGallery.tsx` к путям добавляется префикс **`/api`** (например `/api/uploads/...`) для раздачи через API. Если в БД записать полный `https://...`, текущий код превратит его в `/api/uploads/https://...` и картинка не откроется.

**Вывод для дверей:**

- Либо в PropertyPhoto хранить **только локальные пути** `/uploads/...` (файлы предварительно скачать и положить в `public/uploads`),  
- Либо доработать `complete-data`/`photos-batch` и фронт (StickyPreview, ModernPhotoGallery): если `photoPath`/`photo` начинается с `http://` или `https://`, использовать значение как есть, без префикса `/api/uploads/`.

### 1.4 Наличники, ручки, ограничители

Для них фото идут через **ProductImage**. В `ProductDisplay.tsx` и каталоге используется `image.url` напрямую как `src`. Поэтому:

- Можно сразу сохранять в `ProductImage.url` **полный URL** (в т.ч. Yandex 360) — отображение будет работать.
- Либо после загрузки в своё хранилище подменять `url` на ссылку из хранилища.

---

## 2. Готовность БД и приложения к загрузке новых данных

### 2.1 Схема и ограничения

- **Product:** обязательны `catalog_category_id`, `sku`, `name`, `base_price`; `dimensions`, `properties_data` по умолчанию `"{}"`. Остальное — по документации схемы.
- **ProductImage:** обязательны `product_id`, `filename`, `original_name`, `url`, `mime_type`; при создании через `productRepository.addImage()` передаются все нужные поля.
- **PropertyPhoto:** уникальность по `(categoryId, propertyName, propertyValue, photoType)`.
- **CatalogCategory:** таблица есть, FK со стороны Product и других сущностей. Категории **не создаются в seed** (в `prisma/seed.ts` только пользователи). Значит, дерево категорий должно быть создано вручную (админка) или отдельным скриптом/миграцией.

### 2.2 Захардкоженные ID категорий

В коде жёстко прописаны ID категорий:

| ID | Назначение |
|----|------------|
| `cmg50xcgs001cv7mn0tdyk1wo` | Межкомнатные двери |
| `cmg50xchb001wv7mnbzhw5y9r` | Ручки |
| `cmg50xchh0024v7mn2b5ri4qy` | Комплекты фурнитуры |
| (пустая строка в doors-import) | Ограничители |
| Наличники | Отдельно не захардкожен в текущем импорте |

Используются в: `lib/services/doors-import.service.ts`, `app/api/catalog/doors/complete-data/route.ts`, `app/api/catalog/doors/photos-batch/route.ts`, `app/api/catalog/doors/photos/route.ts`, `app/api/catalog/hardware/route.ts` и др.

**Чтобы БД была уверенно готова к новым данным:**

1. **Проверить наличие категорий** с этими ID (или создать дерево категорий с именами: Межкомнатные двери, Наличники, Комплекты фурнитуры, Ручки, Ограничители) и при необходимости заменить пустой `LIMITERS_CATEGORY_ID` на реальный ID.
2. **Перед массовым импортом:** очистить только данные, которые будете перезаписывать (например, Product + ProductImage; при смене логики дверей — при необходимости PropertyPhoto для категории дверей). Категории и пользователи не трогать.
3. **Рекомендация на будущее:** заменить хардкод ID на получение ID по имени категории из БД (как уже сделано в `lib/export/puppeteer-generator.ts` и `app/api/price/doors/route.ts` через `where: { name: 'Межкомнатные двери' }`).

### 2.3 Чек-лист готовности

- [ ] В `catalog_categories` есть записи для: Межкомнатные двери, Наличники, Комплекты фурнитуры, Ручки, Ограничители (или созданы скриптом/админкой).
- [ ] Известны актуальные `id` этих категорий; в импорте и, при необходимости, в API подставлены правильные ID (в т.ч. для ограничителей и наличников).
- [ ] Решено: импорт будет только добавлять/обновлять Product (+ ProductImage) или также перезаполнять PropertyPhoto для дверей.
- [ ] При полной замене каталога: порядок очистки без нарушения FK (например, сначала ProductImage, потом Product).

---

## 3. Как данные и фото из файла используются в конфигураторе

### 3.1 Источники данных конфигуратора

- **Двери (модели, размеры, фото):**  
  `useConfiguratorData()` → GET `/api/catalog/doors/complete-data`.  
  Ответ: список моделей с полями `model`, `modelKey`, `style`, `photo`, `photos: { cover, gallery }`, `products` (массив товаров с `properties`).

- **Фото дверей:**  
  - В `complete-data` для каждой модели вызывается `getPropertyPhotos(categoryId, 'Артикул поставщика' | 'Domeo_Название модели для Web', value)` → таблица **PropertyPhoto**.  
  - Пути нормализуются к виду `/uploads/...` и возвращаются в `photo` и `photos.cover`/`photos.gallery`.  
  - На фронте `StickyPreview` и галерея ожидают путь и добавляют `/api` для запроса к приложению.

- **Ручки/ограничители (опции):**  
  `useConfiguratorData()` → GET `/api/catalog/doors/options` (с авторизацией). Ручки приходят из `domain.handles` (каталог товаров категории «Ручки» и т.п.).

- **Общий каталог (товары по категориям):**  
  `/api/catalog/products` (categoryId, search, limit, offset). В ответе у каждого товара есть `images` из **ProductImage** (`id`, `url`, `alt_text`, `is_primary`, `sort_order`).

- **Конфигурируемые товары (блоки конструктора):**  
  POST `/api/catalog/configurable-products`. Изображения берутся из `product.images`; если в `properties_data` есть массив `photos`, он подменяет изображения (для обратной совместимости).

### 3.2 Какие поля продукта использует конфигуратор

- **complete-data (двери):**  
  Из Product берутся `id`, `sku`, `properties_data`. Из `properties_data` используются:
  - «Артикул поставщика» — ключ модели и поиск фото в PropertyPhoto;
  - «Domeo_Название модели для Web» — отображаемое имя модели;
  - «Domeo_Стиль Web» — стиль;
  - «Ширина/мм», «Высота/мм» — размеры (в `useConfiguratorData` маппятся в `sizes`: `width`, `height`).

- **Калькулятор/фильтры:**  
  `CatalogDataSource.findProducts()` и API каталога используют `properties_data` для фильтрации и отображения. Имена полей в `properties_data` должны совпадать с теми, что ожидает фронт (например, «Ширина/мм», «Высота/мм» для размеров в конфигураторе дверей).

- **Фото:**  
  - Двери: только PropertyPhoto (по артикулу/названию модели).  
  - Остальные товары: ProductImage, отображаются по `url` как есть (поддержка полного URL уже есть).

### 3.3 Маппинг Excel → БД и конфигуратор

Чтобы данные из `final_filled 30.01.xlsx` корректно попали в конфигуратор:

- В **properties_data** товаров дверей обязательно класть:
  - Ключи для поиска фото: «Артикул поставщика», «Domeo_Название модели для Web» (как в complete-data и photos-batch).
  - Размеры: «Ширина/мм», «Высота/мм» (как в useConfiguratorData).
  - Остальные поля (стиль, покрытие, стекло, кромка и т.д.) — по необходимости для фильтров и отображения.
- Имена полей в Excel (например «Высота, мм», «Ширины, мм») при импорте нужно маппить в эти ключи `properties_data`, либо поправить конфигуратор под новые имена (один источник правды).

---

## 4. Что делать дальше (пошагово)

### Шаг 1: Категории и ID

- Убедиться, что в БД есть все нужные категории (Межкомнатные двери, Наличники, Комплекты фурнитуры, Ручки, Ограничители).
- Получить их ID (через админку или запрос к БД). При отсутствии — создать категории (скрипт или админка) и обновить константы в `doors-import.service.ts` и, при необходимости, в API (photos-batch, complete-data, hardware и т.д.).
- Заполнить `LIMITERS_CATEGORY_ID` и при необходимости добавить константу для наличников.

### Шаг 2: Решение по фото

- **ProductImage (наличники, ручки, ограничители):**  
  Решить: хранить в `url` ссылку из файла (Yandex 360) или после скачивания — URL из своего хранилища. Для отображения достаточно сохранять URL в БД.
- **Двери (PropertyPhoto):**  
  Либо загружать файлы в `public/uploads` и в PropertyPhoto писать пути `/uploads/...`; либо сохранять в PropertyPhoto полный URL и доработать complete-data + StickyPreview/ModernPhotoGallery для поддержки `http(s):` (использовать как есть).

### Шаг 3: Импорт Product + ProductImage (и при необходимости PropertyPhoto)

- Реализовать импорт из `final_filled 30.01.xlsx` в формате, описанном в `docs/FINAL_FILLED_3001_ANALYSIS.md`:
  - Product: категория, sku, name, base_price, properties_data (с нужными ключами для конфигуратора), dimensions при необходимости.
  - ProductImage: по одной или нескольким ссылкам/путям на товар (ручки/завертки — два изображения; остальное — по одному или галерее).
- Для дверей: либо заполнять PropertyPhoto (по артикулу/названию модели) из листа «Цвет» и др., либо планировать переход на ProductImage позже (с доработкой complete-data).

### Шаг 4: Очистка перед импортом (при полной замене)

- Удалить в порядке FK: записи ProductImage, затем Product (при необходимости — выборочно PropertyPhoto для категории дверей).
- Не удалять CatalogCategory и пользователей.

### Шаг 5: Проверка в конфигураторе

- Открыть конфигуратор дверей: список моделей, размеры, фото (complete-data + photos-batch).
- Проверить ручки, ограничители, наличники, комплекты фурнитуры в каталоге и в опциях дверей (если используются).
- Убедиться, что фильтры и калькулятор используют те же ключи `properties_data`, что и импорт.

### Шаг 6 (опционально): Фото «полностью у нас»

- Реализовать пайплайн: скачать по URL из БД/файла → загрузить в Yandex Object Storage (или `public/uploads`) → обновить `ProductImage.url` / `PropertyPhoto.photoPath`. Запускать после основного импорта или по кнопке «Мигрировать фото».

---

Итог: БД и приложение готовы к загрузке новых данных после проверки категорий и подстановки корректных ID. Фото можно сначала учитывать в БД по URL из файла; для дверей нужно либо класть файлы в `public/uploads` и пути в PropertyPhoto, либо доработать поддержку полных URL в complete-data и на фронте. Использование данных и фото в конфигураторе полностью завязано на описанные API, таблицы ProductImage/PropertyPhoto и ключи в `properties_data` — маппинг из Excel в эти поля обеспечит корректную работу конфигуратора после импорта.
