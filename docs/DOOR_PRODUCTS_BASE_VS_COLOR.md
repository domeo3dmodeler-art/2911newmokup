# Товары дверей: базовые комбинации и раздувание из‑за цвета

## Что произошло

В какой‑то момент в БД в явном виде завели товары-двери для каждой **базовой** комбинации (модель + размер + покрытие) и дополнительно ввели измерение **цвет** (Цвет/Отделка), который **не зависит от размера**, а зависит от **названия модели**.

В результате:
- **Было:** ~2000 товаров — по одной записи на (модель, размер, покрытие).
- **Стало:** ~12 000 товаров — по одной записи на (модель, размер, покрытие, **цвет**).

Текущий анализ по локальной БД:
- **Уникальных базовых комбинаций** (модель + ширина + высота + тип покрытия, без цвета): **2020**.
- **Товаров в БД:** 12 972.
- **Раздувание:** в ~6.4 раза; в среднем ~6.2 разных цвета на одну базу.

То есть цвет привязан к модели (к названию/коду модели), а не к размеру. Хранение отдельной строки в `products` на каждую (модель, размер, покрытие, цвет) и дало рост с ~2000 до ~12k.

## Как сейчас устроено

- **Группировка в API:** товары группируются по **Код модели Domeo (Web)**. Для каждой модели список покрытий и цветов (coatings, colorsByFinish) строится из **всех** товаров этой модели — т.е. из набора пар (Тип покрытия, Цвет/Отделка).
- **Цена/экспорт:** подбор конкретного товара для корзины/заказа идёт по (модель, размер, покрытие, цвет, поставщик и т.д.); в БД при этом ожидается строка с таким набором свойств.

То есть логика приложения уже опирается на то, что в БД есть товар на каждую (модель, размер, покрытие, цвет). Уменьшить число записей без изменения логики нельзя без перехода на «базовые» товары.

## Варианты нормализации

### 1. Оставить как есть

- Плюсы: ничего не менять, всё уже работает.
- Минусы: 12k записей, тяжёлый complete-data, больше памяти и времени на импорт/экспорт.

### 2. Перейти на «базовые» товары (~2000 записей)

Хранить в `products` только **одну запись на (модель, размер, покрытие)** (без размножения по цвету). Цвета на уровне модели:
- брать из **PropertyPhoto** (Domeo_Модель_Цвет: код|покрытие|цвет) и/или
- из отдельного справочника «модель → список цветов по покрытиям».

Что потребуется:
- **API complete-data:** строить coatings/colorsByFinish не из товаров, а из PropertyPhoto или отдельной таблицы/поля по модели.
- **Цена/подбор товара:** при выборе (модель, размер, покрытие, цвет) либо не привязываться к конкретной строке продукта по цвету (брать любую подходящую по модели/размеру/покрытию), либо хранить маппинг цвет→представитель в отдельной структуре.
- **Экспорт в Excel/заказ:** в документах по-прежнему передавать выбранный цвет; в БД для расчёта цены использовать один «базовый» товар на (модель, размер, покрытие).
- **Миграция:** скрипт, который для каждой базовой комбинации оставляет один товар (например, первый по id или по одному «представительскому» цвету), остальные помечает `is_active: false` или удаляет; плюс проверка, что все нужные цвета по моделям есть в PropertyPhoto/справочнике.

### 3. Промежуточный вариант

- Удалить только **полные дубликаты** (одинаковые модель + размер + покрытие + цвет + поставщик) и явные дубликаты «одна конфигурация — один поставщик — несколько записей». Это уменьшит объём на десятки записей, но не вернёт к ~2000.

## Анализ по текущей БД

Запуск:

```bash
npx tsx scripts/analyze-door-products.ts
```

Скрипт выводит:
- число записей и уникальных базовых комбинаций (модель + размер + покрытие, без цвета);
- среднее число цветов на базу и коэффициент раздувания;
- дубликаты по полной конфигурации и полные дубликаты (кандидаты на удаление).

Имеет смысл перед любым массовым удалением/дедупликацией делать бэкап БД и при необходимости тестировать на копии.
