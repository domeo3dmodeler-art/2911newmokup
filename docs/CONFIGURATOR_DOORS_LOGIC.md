# Конфигуратор дверей (/doors) — логика и связь с БД

## Порядок действий для корректного отображения опций и расчёта цены

1. **API для опций из БД**  
   Добавить в `GET /api/catalog/hardware` поддержку `type=limiters` и `type=architraves`: отдавать товары категорий «Ограничители» и «Наличники» (id, name, price, photo_path).

2. **Загрузка в конфигураторе**  
   В `useConfiguratorData()` загружать ограничители (`/api/catalog/hardware?type=limiters`) и наличники (`?type=architraves`), сохранять в state и возвращать `limiters` и `architraves`.

3. **Отображение в UI**  
   На странице `/doors` использовать `allLimiters` для блока «Ограничитель» (список + фото), а `allArchitraves` — для блока «Наличники» (вместо пустого `options`).

4. **Передача параметров в расчёт цены**  
   В `usePriceCalculation` и при вызове `calculatePrice()` передавать в `selection`: `color` (название цвета для точного подбора полотна), `edge_id`, `limiter_id`, `option_ids` (в т.ч. id наличников).

5. **Учёт в API цены**  
   В `POST /api/price/doors` использовать `selection.color` при подборе товара двери; при наличии `selection.limiter_id` и `selection.option_ids` добавлять цену ограничителя и выбранных опций к итогу и в `breakdown`.

*(Зеркало и порог: при появлении категорий/источника данных — добавить тип в hardware API и опции в конфигураторе по тому же принципу.)*

---

## Обзор

Страница `http://localhost:3000/doors` — конфигуратор межкомнатных дверей. Ниже разобраны все опции, источники данных (БД / не БД) и цепочка выбора от стиля до корзины.

---

## 1. Вкладки и блоки UI

| Вкладка / блок | Что выбирает пользователь | Источник данных |
|----------------|---------------------------|-----------------|
| **Стили** | Стиль двери (Современные, Классика, и т.д.) | БД (из полотен) |
| **Модели** | Модель полотна (сетка карточек) | БД (complete-data) |
| **Полотно** | Ширина, высота, реверс, наполнение | Локально + размеры из БД по модели |
| **Покрытие и цвет** | Тип покрытия (ПВХ, Эмаль, Шпон…) и цвет | БД (complete-data + PropertyPhoto) |
| **Фурнитура** | Комплект фурнитуры, ручка, замок | БД (ручки — hardware API) |
| **Наличники** | Вариант наличника | **Не из БД** (options = []) |
| **Доп. опции** | Ограничитель, зеркало, порог | Частично (см. ниже) |

---

## 2. Источники данных по API

### 2.1 `GET /api/catalog/doors/complete-data`

- **Вызов:** при загрузке страницы и при открытии деталей модели (хуки `useConfiguratorData`, `useModelDetails`).
- **Параметр:** `?style=...` опционален (на фронте не передаётся — фильтр стиля по клиенту).

**Из БД:**
- Категория «Межкомнатные двери» → все активные товары (`Product`).
- По каждому товару: `properties_data` (JSON) — код модели, название, стиль, тип покрытия, цвет, кромка, размеры и т.д.
- Группировка по **«Код модели Domeo (Web)»** → одна карточка модели в UI = один `modelKey`, может объединять несколько артикулов.
- **Фото моделей и цветов:** `PropertyPhoto` (свойство `Domeo_Модель_Цвет` и обложки по артикулу / названию модели). Пути нормализуются в `normalizePhotoPath` (в т.ч. `/uploads/...`).

**В ответе по каждой модели:**
- `model`, `modelKey`, `style`, `photo`, `photos`, `products[]`, `coatings[]`, `colorsByFinish`, `options.finishes` и т.д.
- **Кромки (edges):** собираются из `products[].properties['Кромка']` — то есть из БД (свойства товаров).

**Итог:** модели, стили, покрытия, цвета, кромки и фото цветов — из БД (Product + PropertyPhoto).

---

### 2.2 `GET /api/catalog/hardware?type=handles`

- **Вызов:** при загрузке страницы (`useConfiguratorData`).
- **Из БД:** категория «Ручки и завертки» → товары с `ProductImage` (поле `url` → массив `photos` в ответе).
- Ручки группируются по полю «Группа» из свойств.

**Итог:** список ручек и их фото — из БД (Product + ProductImage).

---

### 2.3 Ограничители (limiters)

- В `useConfiguratorData` выполняется `setLimiters([])` — **ограничители ниоткуда не загружаются**.
- В UI блок «Ограничитель» строится из `allLimiters` → всегда только пункт «Без ограничителя».
- В БД есть категория «Ограничители» и товары с фото, но **с конфигуратором они не связаны** — отдельного API для лимитеров на странице нет.

**Итог:** опции ограничителей в конфигураторе **не из БД** (список пустой).

---

### 2.4 Опции: наличники, зеркало, порог

- В `useModelDetails` после разбора модели вызывается `setOptions([])` — **опции всегда пустой массив**.
- В UI:
  - `architraveOptions` = `options.filter(o => o.option_type === 'наличники')` → пусто;
  - `mirrorOptions` = `options.filter(o => o.option_type === 'зеркало')` → пусто;
  - `thresholdOptions` = `options.filter(o => o.option_type === 'порог')` → пусто.

**Итог:** наличники, зеркало, порог в конфигураторе **не из БД** (списки пустые, в UI по сути не отображаются как выбор).

---

## 3. Логика выбора по шагам

### 3.1 Стиль

- **Список стилей:** `availableStyles` = уникальные значения `model.style` по всем моделям из complete-data (т.е. из БД: `Domeo_Стиль Web`).
- **Выбор:** `selectedStyle` (useState). Фильтр моделей: `filteredModels = allModels.filter(m => m.style === selectedStyle)`.
- При первой загрузке, если есть модели, выставляется первый стиль из списка и первая модель в списке.

### 3.2 Модель

- **Список:** `filteredModels` (только модели выбранного стиля).
- **Выбор:** `selectedModelId` (= `modelKey` из API). По нему запрашиваются детали: `useModelDetails(selectedModelId)` снова дергает complete-data и из ответа достаёт нужную модель.
- Из выбранной модели берутся: `coatings`, `finishes`, `colorsByFinish`, `edges`. **options** в коде не заполняются (всегда []).

### 3.3 Полотно: размеры, реверс, наполнение

- **Ширина / высота:** локальный state (`width`, `height`). В complete-data по модели есть `products[].properties['Ширина/мм']`, `['Высота/мм']` — используются для размеров в карточке/превью, но не как единственный источник выбора размера пользователем.
- **Реверс, наполнение:** только локальный state (`reversible`, `filling`). **В расчёт цены и в API не передаются** (в текущем коде нет привязки к БД/ценам).

### 3.4 Покрытие и цвет

- **Типы покрытия:** `finishes` из выбранной модели (complete-data) — из БД (уникальные `coating_type` по coatings).
- **Выбор типа:** `selectedFinish`. Цвета по типу: `colorsByFinish[selectedFinish]` (из той же модели).
- **Выбор цвета:** `selectedCoatingId` (id = ключ вида `coating_type_color_name`). Текст для корзины/превью: `getCoatingText()` по `coatings.find(c => c.id === selectedCoatingId)`.
- Фото цветов: `coatings[].photo_path` / `colorsByFinish` — из PropertyPhoto (БД).

### 3.5 Кромка

- **Список:** `edgeOptions` из `edges` (useModelDetails) — из полей `products[].properties['Кромка']` (БД).
- **Выбор:** `selectedEdgeId`. Участвует в расчёте цены и в корзине.

### 3.6 Фурнитура

- **Комплект:** `selectedHardwareKit` — в коде есть state, но загрузка списка комплектов с сервера на странице не видна (можно уточнить отдельным запросом к каталогу).
- **Ручка:** список из `allHandles` (hardware API). Выбор — `selectedHandleId`. Передаётся в расчёт цены и в корзину.
- **Замок:** `hasLock` — только локальный state, в API цены не передаётся.

### 3.7 Наличники

- **Список:** `architraveOptions` из `options` → всегда пустой.
- **Выбор:** `selectedArchitraveId` сохраняется и уходит в корзину/расчёт цены, но **выбирать не из чего** (нет данных из БД).

### 3.8 Доп. опции: ограничитель, зеркало, порог

- **Ограничитель:** список = «Без ограничителя» + `allLimiters` (всегда []). Фактически только «Без ограничителя». `selectedStopperId` и цвет ограничителя (`selectedStopperIdColor`) передаются в корзину; лимитеры из БД не подтягиваются.
- **Зеркало, порог:** списки из `options` → пустые. В корзину и в расчёт цены передаются `selectedMirrorId`, `selectedThresholdId`, но вариантов выбора нет.

---

## 4. Расчёт цены

- **Условие включения расчёта:** `canCalculatePrice` = выбраны стиль, модель, ширина, высота, тип покрытия и цвет (`selectedFinish`, `selectedCoatingId`).
- **Запрос:** `POST /api/price/doors` с телом `{ selection }`.

В **selection** сейчас передаётся (из `usePriceCalculation` и вызова `calculatePrice` в странице):

- `model` — выбранный modelKey (обязательно);
- `style`, `finish`, `width`, `height`;
- `handle` — `{ id: selectedHandleId }` при выборе ручки.

**Не передаётся в selection (но есть в параметрах хука):**  
`coating_id`, `edge_id`, `option_ids`, `limiter_id` в хуке в расчёт цены передаются, но в текущей реализации `usePriceCalculation` в теле запроса формируются только `model`, `style`, `finish`, `width`, `height`, `handle`. То есть **конкретный цвет (Domeo_Цвет), кромка, опции и ограничитель в API цены не попадают** (или не все поля мапятся в selection).

В **price/doors** (POST):

- Ищутся товары категории «Межкомнатные двери» по `style`, `model`, `finish`, `width`, `height`; есть также проверка `selection.color` (свойство `Domeo_Цвет`), но фронт **color в selection не передаёт** — только `coating_id`. Поэтому расчёт может идти без привязки к точному цвету (любой цвет подходит при совпадении остального).
- При наличии `selection.handle.id` к цене двери добавляется ручка (из БД).
- Комплект фурнитуры учитывается по `selection.hardware_kit.id`, если передан.

---

## 5. Корзина и документы

- В корзину попадают: модель, стиль, размеры, цвет (текст из `getCoatingText()`), кромка, ручка, ограничитель, наличники/зеркало/порог (id опций), цена из `priceData`, sku из ответа цены.
- Генерация документов (КП, счёт, заказ) отправляет на бэкенд массив позиций корзины с теми же полями (model, style, color, width, height, handleId, limiterId, optionIds и т.д.).

---

## 6. Сводная таблица: связь с БД

| Данные | Из БД? | API / таблица |
|--------|--------|----------------|
| Стили | Да | complete-data → Product.properties_data['Domeo_Стиль Web'] |
| Модели (список и фото) | Да | complete-data → Product + PropertyPhoto |
| Размеры по модели | Да | complete-data → Product.properties_data (Ширина/мм, Высота/мм) |
| Типы покрытия и цвета | Да | complete-data → PropertyPhoto (Domeo_Модель_Цвет) + products |
| Фото цветов | Да | PropertyPhoto.photoPath |
| Кромки | Да | complete-data → Product.properties_data['Кромка'] |
| Ручки и фото ручек | Да | hardware?type=handles → Product + ProductImage |
| Ограничители | Нет (список пустой) | setLimiters([]), API для лимитеров не вызывается |
| Наличники (опции) | Нет (список пустой) | setOptions([]) |
| Зеркало / порог (опции) | Нет (список пустой) | setOptions([]) |
| Реверс, наполнение | Нет | Только локальный state, в API не передаются |
| Расчёт цены | Да | price/doors → Product (дверь + ручка, опционально комплект); color/edge/limiter в selection не все передаются |

---

## 7. Рекомендации по доработке

1. **Ограничители:** загружать список из БД (категория «Ограничители») и подставлять в `useConfiguratorData` или отдельным запросом, заполнять `allLimiters` и передавать в расчёт цены/корзину.
2. **Наличники, зеркало, порог:** определить источник (отдельная категория товаров, свойства дверей или общий справочник опций), заполнять `options` в `useModelDetails` или отдельным API и выводить в UI.
3. **Расчёт цены:** передавать в `selection` цвет (название, например `Domeo_Цвет`), кромку, ограничитель и опции (наличники, зеркало, порог), чтобы цена и sku соответствовали выбранной комбинации.
4. **Реверс / наполнение:** при необходимости учитывать в БД и в API цены (добавить поля в товары и в selection).

Документ составлен по коду: `app/doors/page.tsx`, `lib/configurator/useConfiguratorData.ts`, `app/api/catalog/doors/complete-data/route.ts`, `app/api/catalog/hardware/route.ts`, `app/api/price/doors/route.ts`.
