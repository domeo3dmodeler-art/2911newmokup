# Импорт данных: шаблоны и логика обновления / дубликатов

## 1. Два контура импорта

В проекте используются **два разных** источника Excel и две логики импорта.

| Что | Файл | Где запускается | Структура Excel |
|-----|------|------------------|------------------|
| **Импорт из админки** | **newdata.xlsx** | Админка → Каталог → Импорт (категория «Межкомнатные двери») | 6 листов: 01 Модели Поставщики, 02 Покрытия Цвета, 03 Кромка, 04 Опции Дополнительные, 05 Ручки Завертки, 06 Ограничители |
| **Импорт «final_filled»** | **final_filled 30.01.xlsx** | Только из CLI: `npx tsx scripts/import-final-filled.ts` | Листы: Цены базовые, Цвет, Опции, Стекло_доступность, Наценка за кромку, Наличники, Фурнитура, 04 Ручки Завертки, 05 Ограничители |

**Важно:** шаблон **final_filled 30.01.xlsx** (тот, что используется в документации и в скриптах проверки) **не представлен в админке**. Импорт по нему выполняется только скриптом `scripts/import-final-filled.ts`. В админке доступен только импорт по шаблону **newdata.xlsx** (другая структура листов и полей).

Чтобы в админке можно было заливать данные из формата final_filled (цены, опции, цвет, кромка и т.д.), нужно либо добавить отдельный пункт «Импорт final_filled» с загрузкой файла и вызовом той же логики, что в `import-final-filled.ts`, либо завести отдельный шаблон импорта под этот формат.

---

## 2. Логика обновления и дубликаты: import-final-filled.ts (final_filled 30.01.xlsx)

Скрипт читает файл из `1002/final_filled 30.01.xlsx` и пишет в БД. Идентификация записей и поведение при «дубликатах»:

### 2.1 Двери (Product, категория «Межкомнатные двери»)

- **Уникальный ключ (SKU):**  
  `door_<код_модели>_<ширина>_<высота>_<тип_покрытия>`  
  Код и тип покрытия приводятся к slug (латиница/цифры/подчёркивание, до 80 символов).
- **Логика:** один вызов `prisma.product.upsert` на каждую комбинацию (строка «Цены базовые» × размеры).
  - **create** — если продукта с таким SKU ещё нет: создаётся запись (name, base_price, properties_data, dimensions).
  - **update** — если продукт с таким SKU уже есть: обновляются name, base_price, properties_data (полная перезапись свойств по текущей строке Excel).
- **Дубликаты:** дубликатом считается запись с тем же SKU. В Excel может быть несколько строк с одним кодом модели и одними размерами, но разным типом покрытия — тогда получаются разные SKU (разные товары). Строки с одинаковыми кодом, размером и типом покрытия дают один и тот же SKU → при повторном импорте только обновление, новых записей не создаётся.

### 2.2 Цвет (PropertyPhoto)

- **Уникальный ключ:** категория + свойство `Domeo_Модель_Цвет` + значение `propertyValue` = `<Название модели>|<Тип покрытия>|<Цвет/отделка>`.
- Логика: upsert по (categoryId, propertyName, propertyValue): если запись есть — обновляется фото (обложка/галерея), если нет — создаётся.
- Дубликаты: одна запись на комбинацию (модель, тип покрытия, цвет). Повторный импорт обновляет фото.

### 2.3 Наличники, ручки, ограничители (Product)

- **Уникальный ключ:** SKU (например `nalichnik_<slug(название)>`, `handle_<slug(название)>`, `limiter_<slug(название)>`).
- Логика: `prisma.product.upsert` по `sku`: при наличии — update, при отсутствии — create.
- Дубликаты: по SKU. Один и тот же SKU при повторном импорте только обновляется.

### 2.4 Итог по final_filled

- Обновление данных: при каждом запуске скрипта все обработанные строки Excel применяются через upsert; существующие записи с тем же ключом (SKU или propertyValue) перезаписываются.
- Дубликаты не создаются: повторный импорт не добавляет новых записей с тем же ключом, только обновляет их.
- Добавление новых данных: новые строки в Excel (новый SKU для дверей или новый propertyValue для цветов) приводят к созданию новых записей в БД.

---

## 3. Логика обновления и дубликаты: админский импорт (DoorsImportService, newdata.xlsx)

Используется в админке при выборе категории «Межкомнатные двери» и загрузке файла **newdata.xlsx**. Режим задаётся параметром **updateMode**: `replace` | `merge` | `add_new`.

### 3.1 Модели (лист 01 Модели Поставщики)

- Товары создаются по комбинациям размеров (width × height) из JSON-поля «Размеры».
- **SKU** в коде формируется как `DOOR_${modelName}_${width}x${height}_${Date.now()}` — то есть при каждом создании в SKU попадает текущее время, из‑за чего один и тот же «логический» товар при повторном импорте может получить новый SKU и создаться как дубликат, если не сработает ветка обновления.
- Поиск существующего: `findFirst` по `catalog_category_id` и `sku: { startsWith: 'DOOR_${modelName}_' }` — берётся **первый** попавшийся товар с таким префиксом, без привязки к размеру.
- **replace:** если такой товар найден — полное обновление (update) его полей данными из строки; иначе — create.
- **merge:** если найден — update с объединением старых и новых properties_data; иначе — create.
- **add_new:** всегда create (новый SKU с Date.now() → при каждом импорте возможны дубликаты по сути одной и той же модели/размера).

Итог: дубликаты определяются не по стабильному ключу (например, модель+размер), а по префиксу SKU и «первому найденному»; при add_new дубликаты по сути одной модели/размера возможны.

### 3.2 Покрытия (02), Кромка (03), Опции (04)

- Ищутся товары дверей по полю в properties_data (например, по названию модели) и обновляются их свойства. Новые товары не создаются; дубликаты на уровне листов покрытий/кромки/опций не определяются по отдельному ключу — обновляются все найденные товары модели.

### 3.3 Ручки (05), Ограничители (06)

- Уникальный ключ: **SKU** (из названия и т.п.).
- **replace:** найден по SKU → полная замена данными из Excel.
- **merge:** найден по SKU → обновление с объединением свойств.
- **add_new:** если запись с таким SKU уже есть — пропуск; иначе создание. Дубликаты по одному SKU не создаются.

---

## 4. Рекомендации

1. **Шаблон final_filled в админке:** чтобы в интерфейсе можно было заливать и обновлять данные из формата final_filled 30.01.xlsx, имеет смысл добавить в админку отдельный поток импорта (например, «Импорт final_filled»), который принимает загруженный файл и выполняет ту же логику, что и `scripts/import-final-filled.ts` (включая формирование SKU и upsert по ним). Тогда не нужно будет вручную класть файл в `1002/` и запускать скрипт из CLI.
2. **Единая логика дубликатов:** для дверей в обоих контурах лучше использовать стабильный SKU без временных меток (как в import-final-filled: код модели + размер + тип покрытия), а поиск «существующего» товара — по этому SKU, чтобы однозначно определять обновление и не создавать дубликаты.
3. **Документация для пользователей админки:** в интерфейсе импорта указать, какой файл ожидается (newdata.xlsx с перечнем листов) и что импорт по формату «Цены базовые / Цвет / Опции…» (final_filled) выполняется отдельно — пока через скрипт, после доработки — через соответствующий пункт в админке.
